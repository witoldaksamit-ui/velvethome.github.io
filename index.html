<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Temperature — Last 24 Hours</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 20px; color: #111; }
    header { display:flex; align-items:center; gap:16px; margin-bottom:12px; }
    h1 { font-size:1.1rem; margin:0; }
    .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
    .range-btn {
      padding:6px 10px;
      border-radius:6px;
      border:1px solid #bbb;
      background:#f6f6f6;
      cursor:pointer;
    }
    .range-btn:hover { background:#eef; }
    .range-btn.active {
      background:#1976d2;
      color:#fff;
      border-color: #1565c0;
    }
    #stats { margin-top:8px; font-size:0.95rem; }
    canvas { background: #fff; border:1px solid #ddd; border-radius:6px; max-width:100%; display:block; margin-bottom:12px; }
    .legend { margin-top:8px; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .dot { width:12px; height:12px; border-radius:50%; display:inline-block; margin-right:6px; vertical-align:middle; }
    @media (max-width:600px){ header { flex-direction:column; align-items:flex-start } }
  </style>
</head>
<body>
  <header>
    <h1>Temperature — Last 24 hours</h1>
    <!-- <div style="color:#666;font-size:0.95rem;">Reads a plaintext file and draws the last-N-hours graphs (top and bottom)</div> -->
  </header>

  <div class="controls" role="toolbar" aria-label="Select time range">
    <button id="range6Btn" class="range-btn" aria-pressed="false">6 hours</button>
    <button id="range12Btn" class="range-btn" aria-pressed="false">12 hours</button>
    <button id="range24Btn" class="range-btn" aria-pressed="true">24 hours</button>
  </div>

  <div id="stats" aria-live="polite"></div>

  <!-- Top chart -->
  <canvas id="chartTop" width="1000" height="320" role="img" aria-label="Temperatura w domu — wykres za ostatnie godziny"></canvas>
  <!-- Bottom chart -->
  <canvas id="chartBottom" width="1000" height="320" role="img" aria-label="Temperatura na dworze — wykres za ostatnie godziny"></canvas>

  <div class="legend">
    <span><span class="dot" style="background:#1976d2"></span>Temperatura w domu</span>
    <span><span class="dot" style="background:#d32f2f"></span>Temperatura na dworze</span>
  </div>

  <script>
  (function () {
    const canvasTop = document.getElementById('chartTop');
    const ctxTop = canvasTop.getContext('2d');
    const canvasBottom = document.getElementById('chartBottom');
    const ctxBottom = canvasBottom.getContext('2d');

    const statsEl = document.getElementById('stats');
    const range6Btn = document.getElementById('range6Btn');
    const range12Btn = document.getElementById('range12Btn');
    const range24Btn = document.getElementById('range24Btn');

    let rawDataText = null;
    let parsedPoints = []; // {t:Date, v1:Number|null, v2:Number|null}
    let timeRangeHours = 24; // default (common for top & bottom)

    function setRangeHours(h) {
      timeRangeHours = h;
      updateRangeButtons();
      updateAndDraw();
    }

    function updateRangeButtons() {
      const map = [
        {btn: range6Btn, h: 6},
        {btn: range12Btn, h: 12},
        {btn: range24Btn, h: 24}
      ];
      for (const item of map) {
        const active = item.h === timeRangeHours;
        item.btn.classList.toggle('active', active);
        item.btn.setAttribute('aria-pressed', active ? 'true' : 'false');
      }
      // update canvas aria labels to mention selected hours
      canvasTop.setAttribute('aria-label', `Temperatura w domu — wykres za ostatnie ${timeRangeHours} godzin`);
      canvasBottom.setAttribute('aria-label', `Temperatura na dworze — wykres za ostatnie ${timeRangeHours} godzin`);
    }

    range6Btn.addEventListener('click', () => setRangeHours(6));
    range12Btn.addEventListener('click', () => setRangeHours(12));
    range24Btn.addEventListener('click', () => setRangeHours(24));

    // Parse text lines. Supported:
    //  - timestamp, v1, v2
    //  - timestamp, v   (v -> both series)
    //  - single numeric per line -> treated as value for both series (timestamps auto-assigned)
    function parseText(text) {
      const lines = text.split(/\r?\n/);
      const points = [];
      for (let raw of lines) {
        const line = raw.trim();
        if (!line) continue;
        if (line.startsWith('#')) continue;
        const parts = line.split(/[,\t]/).map(s => s.trim()).filter(Boolean);
        if (parts.length >= 3) {
          const tstr = parts[0];
          const v1 = Number(parts[1]);
          const v2 = Number(parts[2]);
          if (isNaN(v1) && isNaN(v2)) continue;
          const t = parseTimestamp(tstr);
          if (!t) continue;
          points.push({ t, v1: isNaN(v1) ? null : v1, v2: isNaN(v2) ? null : v2 });
        } else if (parts.length === 2) {
          // timestamp, value -> use value for both series
          const tstr = parts[0];
          const v = Number(parts[1]);
          if (isNaN(v)) continue;
          const t = parseTimestamp(tstr);
          if (!t) continue;
          points.push({ t, v1: v, v2: v });
        } else if (parts.length === 1) {
          // single number -> only value, timestamp unknown (will be assigned later)
          const v = Number(parts[0]);
          if (isNaN(v)) continue;
          points.push({ t: null, v1: v, v2: v });
        }
      }

      // assign timestamps to points with null t (end now, spaced 1 minute)
      const nulls = points.filter(p => p.t === null);
      if (nulls.length) {
        const now = Date.now();
        const minute = 60000;
        for (let i = 0; i < nulls.length; i++) {
          const ageIndex = nulls.length - 1 - i;
          nulls[i].t = new Date(now - ageIndex * minute);
        }
      }

      // sort ascending
      points.sort((a, b) => a.t - b.t);
      return points;
    }

    function parseTimestamp(s) {
      // ISO?
      const iso = Date.parse(s);
      if (!isNaN(iso)) return new Date(iso);
      // numeric?
      const n = Number(s);
      if (!isNaN(n)) {
        if (n > 1e12) return new Date(n); // ms
        if (n > 1e9) return new Date(n * 1000); // seconds -> ms
      }
      // fallback: try replacing space with T
      const alt = Date.parse(s.replace(' ', 'T'));
      if (!isNaN(alt)) return new Date(alt);
      return null;
    }

    function filterLastHours(points, hours) {
      const now = Date.now();
      const start = now - hours * 60 * 60 * 1000;
      return points.filter(p => p.t.getTime() >= start && p.t.getTime() <= now);
    }

    function computeStats(points, key) {
      const vals = points.map(p => p[key]).filter(v => v !== null && v !== undefined && !isNaN(v));
      if (!vals.length) return null;
      let sum = 0, min = Infinity, max = -Infinity;
      for (const v of vals) {
        sum += v;
        if (v < min) min = v;
        if (v > max) max = v;
      }
      return {
        count: vals.length,
        avg: sum / vals.length,
        min, max,
        first: points.find(p => p[key] !== null && p[key] !== undefined).t,
        last: (() => { for (let i = points.length-1; i >=0; i--) if (points[i][key] !== null && points[i][key] !== undefined) return points[i].t; return null; })()
      };
    }

    // drawing helpers (draw single series on given canvas/context)
    function clearCanvas(ctx, canvas) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawGrid(ctx, x0, y0, x1, y1, xTicks, yTicks) {
      ctx.strokeStyle = '#eee';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (const x of xTicks) {
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y1);
      }
      for (const y of yTicks) {
        ctx.moveTo(x0, y);
        ctx.lineTo(x1, y);
      }
      ctx.stroke();
    }

    function niceTimeLabel(date) {
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    function drawSingleChart(canvas, ctx, points, valueKey, color) {
      clearCanvas(ctx, canvas);

      // filter only points that have a valid value for this series
      const pts = points.filter(p => p[valueKey] !== null && p[valueKey] !== undefined && !isNaN(p[valueKey]));
      if (!pts.length) {
        ctx.fillStyle = '#333';
        ctx.font = '14px system-ui, Arial';
        ctx.fillText('No data available for the selected time range', 20, 40);
        return;
      }

      // layout
      const margin = { left: 60, right: 14, top: 18, bottom: 36 };
      const chartW = canvas.width - margin.left - margin.right;
      const chartH = canvas.height - margin.top - margin.bottom;
      const x0 = margin.left, y0 = margin.top, x1 = margin.left + chartW, y1 = margin.top + chartH;

      // compute min/max for this series
      let vmin = Infinity, vmax = -Infinity;
      for (const p of pts) {
        const v = p[valueKey];
        if (v < vmin) vmin = v;
        if (v > vmax) vmax = v;
      }
      if (vmin === vmax) { vmin -= 1; vmax += 1; }
      else { const pad = (vmax - vmin) * 0.12; vmin -= pad; vmax += pad; }

      const tmin = pts[0].t.getTime();
      const tmax = pts[pts.length-1].t.getTime();

      const mapX = t => x0 + ( (t - tmin) / (tmax - tmin || 1) ) * chartW;
      const mapY = v => y0 + (1 - ( (v - vmin) / (vmax - vmin || 1) )) * chartH;

      // y ticks
      const yTicksCount = 5;
      const yTicks = [];
      const yTickValues = [];
      for (let i=0;i<=yTicksCount;i++) {
        const frac = i / yTicksCount;
        const y = y0 + (1 - frac) * chartH;
        yTicks.push(y);
        yTickValues.push(vmin + frac * (vmax - vmin));
      }

      // x ticks (adaptive)
      const msPerHour = 3600000;
      const rangeHours = Math.max(1, (tmax - tmin) / msPerHour);
      const approxTicks = Math.min(8, Math.max(3, Math.round(rangeHours / 3)));
      const tickIntervalMs = Math.ceil((tmax - tmin) / approxTicks / 60000) * 60000;
      const xTicks = [];
      const xTickDates = [];
      const startDate = new Date(tmin);
      const startMs = Math.floor(startDate.getTime() / tickIntervalMs) * tickIntervalMs;
      for (let ts = startMs; ts <= tmax; ts += tickIntervalMs) {
        xTicks.push(mapX(ts));
        xTickDates.push(new Date(ts));
      }

      // grid
      drawGrid(ctx, x0, y0, x1, y1, xTicks, yTicks);

      // axes
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x0, y1);
      ctx.lineTo(x1, y1);
      ctx.moveTo(x0, y0);
      ctx.lineTo(x0, y1);
      ctx.stroke();

      // y labels
      ctx.fillStyle = '#333';
      ctx.font = '12px system-ui, Arial';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for (let i=0;i<yTickValues.length;i++) {
        const val = yTickValues[i];
        const y = yTicks[i];
        ctx.fillText(Number(val.toFixed(2)), x0 - 8, y);
      }

      // x labels
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      for (let i=0;i<xTickDates.length;i++) {
        const d = xTickDates[i];
        const x = xTicks[i];
        ctx.fillText(niceTimeLabel(d), x, y1 + 6);
      }

      // draw line
      ctx.beginPath();
      ctx.lineWidth = 2.5;
      ctx.strokeStyle = color;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      for (let i=0;i<pts.length;i++) {
        const p = pts[i];
        const x = mapX(p.t.getTime());
        const y = mapY(p[valueKey]);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // area under curve
      ctx.lineTo(mapX(pts[pts.length-1].t.getTime()), y1);
      ctx.lineTo(mapX(pts[0].t.getTime()), y1);
      ctx.closePath();
      ctx.fillStyle = color === '#1976d2' ? 'rgba(25,118,210,0.06)' : 'rgba(211,47,47,0.06)';
      ctx.fill();

      // draw points
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = color;
      ctx.lineWidth = 1.2;
      for (const p of pts) {
        const x = mapX(p.t.getTime());
        const y = mapY(p[valueKey]);
        ctx.beginPath();
        ctx.arc(x, y, 3.2, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
      }

      // interactivity: tooltip on hover for this canvas
      canvas.onmousemove = function (ev) {
        const rect = canvas.getBoundingClientRect();
        const mx = ev.clientX - rect.left;
        const my = ev.clientY - rect.top;
        let best = null, bestDist = Infinity;
        for (const p of pts) {
          const x = mapX(p.t.getTime());
          const y = mapY(p[valueKey]);
          const dx = x - mx, dy = y - my;
          const d2 = dx*dx + dy*dy;
          if (d2 < bestDist) { bestDist = d2; best = {p, x, y}; }
        }
        if (best && bestDist < 14*14) {
          // redraw base chart
          drawSingleChart(canvas, ctx, points, valueKey, color);
          // marker
          ctx.beginPath();
          ctx.fillStyle = color;
          ctx.arc(best.x, best.y, 5, 0, Math.PI*2);
          ctx.fill();
          // tooltip
          const val = best.p[valueKey];
          const txt = best.p.t.toLocaleString() + ' — ' + (val !== null ? val.toFixed(2) : 'n/a') + ' °';
          const padding = 6;
          ctx.font = '12px system-ui, Arial';
          const metrics = ctx.measureText(txt);
          const tw = metrics.width + padding*2;
          const th = 20;
          let tx = best.x + 12;
          let ty = best.y - th - 6;
          if (tx + tw > canvas.width - 6) tx = best.x - tw - 12;
          if (ty < 6) ty = best.y + 12;
          ctx.fillStyle = 'rgba(0,0,0,0.75)';
          roundRect(ctx, tx, ty, tw, th, 6, true, false);
          ctx.fillStyle = '#fff';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.fillText(txt, tx + padding, ty + th/2);
        }
      };

      function roundRect(ctx, x, y, w, h, r, fill, stroke) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
      }
    }

    // Load file using cache-busting query param to avoid cached responses
    async function loadFromFetch() {
      try {
        const url = 'temperatures.txt?ts=' + Date.now();
        const res = await fetch(url, {cache: 'no-store'});
        if (!res.ok) throw new Error('Fetch failed: ' + res.status);
        const txt = await res.text();
        rawDataText = txt;
        parsedPoints = parseText(txt);
        updateAndDraw();
      } catch (err) {
        // non-intrusive: log the failure
        console.warn('Could not fetch temperatures.txt:', err.message, '(same-origin or CORS required).');
      }
    }

    function updateAndDraw() {
      const lastN = filterLastHours(parsedPoints, timeRangeHours);
      const statsHome = computeStats(lastN, 'v1');
      const statsOutside = computeStats(lastN, 'v2');

      // update stats display (Polish labels)
      const homeLine = statsHome
        ? `Temperatura w domu: Count: ${statsHome.count} — Min: ${statsHome.min.toFixed(2)} °, Max: ${statsHome.max.toFixed(2)} °, Avg: ${statsHome.avg.toFixed(2)} ° (From: ${statsHome.first.toLocaleString()} to ${statsHome.last ? statsHome.last.toLocaleString() : 'n/a'})`
        : 'Temperatura w domu: No readings in the selected time range.';
      const outsideLine = statsOutside
        ? `Temperatura na dworze: Count: ${statsOutside.count} — Min: ${statsOutside.min.toFixed(2)} °, Max: ${statsOutside.max.toFixed(2)} °, Avg: ${statsOutside.avg.toFixed(2)} ° (From: ${statsOutside.first.toLocaleString()} to ${statsOutside.last ? statsOutside.last.toLocaleString() : 'n/a'})`
        : 'Temperatura na dworze: No readings in the selected time range.';
      statsEl.innerHTML = `<div>${homeLine}</div><div>${outsideLine}</div>`;

      // draw both charts (home: blue, outside: red)
      drawSingleChart(canvasTop, ctxTop, lastN, 'v1', '#1976d2');
      drawSingleChart(canvasBottom, ctxBottom, lastN, 'v2', '#d32f2f');
    }

    // initial empty messages on both canvases
    clearCanvas(ctxTop, canvasTop);
    ctxTop.fillStyle = '#333';
    ctxTop.font = '14px system-ui, Arial';
    ctxTop.fillText('Loading chart... (will auto-fetch temperatures.txt)', 20, 40);

    clearCanvas(ctxBottom, canvasBottom);
    ctxBottom.fillStyle = '#333';
    ctxBottom.font = '14px system-ui, Arial';
    ctxBottom.fillText('Loading chart... (will auto-fetch temperatures.txt)', 20, 40);

    // Try to automatically fetch temperatures.txt on page load (same-origin or CORS-enabled)
    loadFromFetch();

    // Auto-refresh data once a minute (60000 ms) with error logging
    setInterval(function () {
      loadFromFetch().catch(err => console.warn('Periodic load failed:', err));
    }, 60000);

    // initialize buttons state
    updateRangeButtons();

    // expose parse helper for console (debug)
    window._tempChart = {
      parseText, parseTimestamp, updateAndDraw, parsedPoints, setRangeHours
    };
  })();
  </script>
</body>
</html>
